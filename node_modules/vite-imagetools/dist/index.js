import path, { basename, extname } from 'node:path';
import { builtins, builtinOutputFormats, parseURL, extractEntries, resolveConfigs, generateTransforms, applyTransforms, urlFormat, getMetadata } from 'imagetools-core';
export * from 'imagetools-core';
import { createFilter, dataToEsm } from '@rollup/pluginutils';
import sharp from 'sharp';
import { createHash } from 'node:crypto';
import { statSync } from 'node:fs';

const createBasePath = (base) => {
    return ((base === null || base === void 0 ? void 0 : base.replace(/\/$/, '')) || '') + '/@imagetools/';
};
async function generateImageID(url, config, originalImage) {
    if (url.host) {
        const baseURL = new URL(url.origin + url.pathname);
        const buffer = await originalImage.toBuffer();
        return hash([baseURL.href, JSON.stringify(config), buffer]);
    }
    // baseURL isn't a valid URL, but just a string used for an identifier
    // use a relative path in the local case so that it's consistent across machines
    const baseURL = new URL(url.protocol + path.relative(process.cwd(), url.pathname));
    const { mtime } = statSync(path.resolve(process.cwd(), decodeURIComponent(url.pathname)));
    return hash([baseURL.href, JSON.stringify(config), mtime.getTime().toString()]);
}
function hash(keyParts) {
    let hash = createHash('sha1');
    for (const keyPart of keyParts) {
        hash = hash.update(keyPart);
    }
    return hash.digest('hex');
}

const defaultOptions = {
    include: /^[^?]+\.(avif|gif|heif|jpeg|jpg|png|tiff|webp)(\?.*)?$/,
    exclude: 'public/**/*',
    removeMetadata: true
};
function imagetools(userOptions = {}) {
    const pluginOptions = { ...defaultOptions, ...userOptions };
    const filter = createFilter(pluginOptions.include, pluginOptions.exclude);
    const transformFactories = pluginOptions.extendTransforms ? pluginOptions.extendTransforms(builtins) : builtins;
    const outputFormats = pluginOptions.extendOutputFormats
        ? pluginOptions.extendOutputFormats(builtinOutputFormats)
        : builtinOutputFormats;
    let viteConfig;
    let basePath;
    const generatedImages = new Map();
    return {
        name: 'imagetools',
        enforce: 'pre',
        configResolved(cfg) {
            viteConfig = cfg;
            basePath = createBasePath(viteConfig.base);
        },
        async load(id) {
            var _a, _b, _c, _d, _e, _f, _g;
            if (!filter(id))
                return null;
            const srcURL = parseURL(id);
            // lazy loaders so that we can load the metadata in defaultDirectives if needed
            // but if there are no directives then we can just skip loading
            let lazyImg;
            const lazyLoadImage = () => {
                if (lazyImg)
                    return lazyImg;
                return (lazyImg = sharp(decodeURIComponent(srcURL.pathname)));
            };
            let lazyMetadata;
            const lazyLoadMetadata = async () => {
                if (lazyMetadata)
                    return lazyMetadata;
                return (lazyMetadata = await lazyLoadImage().metadata());
            };
            const defaultDirectives = typeof pluginOptions.defaultDirectives === 'function'
                ? await pluginOptions.defaultDirectives(srcURL, lazyLoadMetadata)
                : pluginOptions.defaultDirectives || new URLSearchParams();
            const directives = new URLSearchParams({
                ...Object.fromEntries(defaultDirectives),
                ...Object.fromEntries(srcURL.searchParams)
            });
            if (!directives.toString())
                return null;
            const img = lazyLoadImage();
            const widthParam = directives.get('w');
            const heightParam = directives.get('h');
            if (directives.get('allowUpscale') !== 'true' && (widthParam || heightParam)) {
                const metadata = await lazyLoadMetadata();
                const clamp = (s, intrinsic) => [...new Set(s.split(';').map((d) => (parseInt(d) <= intrinsic ? d : intrinsic.toString())))].join(';');
                if (widthParam) {
                    const intrinsicWidth = metadata.width || 0;
                    directives.set('w', clamp(widthParam, intrinsicWidth));
                }
                if (heightParam) {
                    const intrinsicHeight = metadata.height || 0;
                    directives.set('h', clamp(heightParam, intrinsicHeight));
                }
            }
            const parameters = extractEntries(directives);
            const imageConfigs = (_b = (_a = pluginOptions.resolveConfigs) === null || _a === void 0 ? void 0 : _a.call(pluginOptions, parameters, outputFormats)) !== null && _b !== void 0 ? _b : resolveConfigs(parameters, outputFormats);
            const outputMetadatas = [];
            const logger = {
                info: (msg) => viteConfig.logger.info(msg),
                warn: (msg) => this.warn(msg),
                error: (msg) => this.error(msg)
            };
            for (const config of imageConfigs) {
                const { transforms } = generateTransforms(config, transformFactories, srcURL.searchParams, logger);
                const { image, metadata } = await applyTransforms(transforms, img.clone(), pluginOptions.removeMetadata);
                if (viteConfig.command === 'serve') {
                    const id = await generateImageID(srcURL, config, img);
                    generatedImages.set(id, image);
                    metadata.src = basePath + id;
                }
                else {
                    const fileHandle = this.emitFile({
                        name: basename(srcURL.pathname, extname(srcURL.pathname)) + `.${metadata.format}`,
                        source: await image.toBuffer(),
                        type: 'asset'
                    });
                    metadata.src = `__VITE_ASSET__${fileHandle}__`;
                }
                metadata.image = image;
                outputMetadatas.push(metadata);
            }
            let outputFormat = urlFormat();
            const asParam = (_c = directives.get('as')) === null || _c === void 0 ? void 0 : _c.split(':');
            const as = asParam ? asParam[0] : undefined;
            for (const [key, format] of Object.entries(outputFormats)) {
                if (as === key) {
                    outputFormat = format(asParam && asParam[1] ? asParam[1].split(';') : undefined);
                    break;
                }
            }
            return dataToEsm(await outputFormat(outputMetadatas), {
                namedExports: (_f = (_d = pluginOptions.namedExports) !== null && _d !== void 0 ? _d : (_e = viteConfig.json) === null || _e === void 0 ? void 0 : _e.namedExports) !== null && _f !== void 0 ? _f : true,
                compact: (_g = !!viteConfig.build.minify) !== null && _g !== void 0 ? _g : false,
                preferConst: true
            });
        },
        configureServer(server) {
            server.middlewares.use((req, res, next) => {
                var _a;
                if ((_a = req.url) === null || _a === void 0 ? void 0 : _a.startsWith(basePath)) {
                    const [, id] = req.url.split(basePath);
                    const image = generatedImages.get(id);
                    if (!image)
                        throw new Error(`vite-imagetools cannot find image with id "${id}" this is likely an internal error`);
                    if (pluginOptions.removeMetadata === false) {
                        image.withMetadata();
                    }
                    res.setHeader('Content-Type', `image/${getMetadata(image, 'format')}`);
                    res.setHeader('Cache-Control', 'max-age=360000');
                    return image.clone().pipe(res);
                }
                next();
            });
        }
    };
}

export { imagetools };
//# sourceMappingURL=index.js.map
